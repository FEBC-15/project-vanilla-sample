# Lion Board 앱 개발

## 목차

- [개발 준비](#개발-준비)
  - [DB 초기화 및 API 서버 테스트 준비](#db-초기화-및-api-서버-테스트-준비)
  - [불필요한 파일 정리](#불필요한-파일-정리)
  - [샘플 코드 복사](#샘플-코드-복사)
  - [vite.config.js 파일 수정](#viteconfigjs-파일-수정)
  - [샘플 코드 테스트](#샘플-코드-테스트)

- [1. Step 01 - Web Components로 공용 HTML 코드 분리](#1-step-01---web-components로-공용-html-코드-분리)
  - [1.1 Web Components란?](#11-web-components란)
    - [1.1.1 주요 기술](#111-주요-기술)
    - [1.1.2 Web Components의 장점](#112-web-components의-장점)
    - [1.1.3 기본 구조](#113-기본-구조)
  - [1.2 프로젝트에 Web Components 적용](#12-프로젝트에-web-components-적용)
    - [1.2.1 User 인터페이스 정의](#121-user-인터페이스-정의)
    - [1.2.2 컴포넌트 작성](#122-컴포넌트-작성)
    - [1.2.3 컴포넌트 적용](#123-컴포넌트-적용)
    - [1.2.4 테스트](#124-테스트)
  - [1.3 라이언 보드 v01 완성](#13-라이언-보드-v01-완성)

- [2. Step 02 - 기본 기능 구현(API 서버 연동)](#2-step-02---기본-기능-구현api-서버-연동)
  - [2.1 type 정의](#21-type-정의)
    - [2.1.1 게시물 타입 정의](#211-게시물-타입-정의)
    - [2.1.2 파일 업로드 타입 정의](#212-파일-업로드-타입-정의)
    - [2.1.3 서버 응답 데이터 타입 정의](#213-서버-응답-데이터-타입-정의)
  - [2.2 공통 함수 정의](#22-공통-함수-정의)
    - [2.2.1 Axios 요청 함수](#221-axios-요청-함수)
  - [2.3 API 요청 함수 정의](#23-api-요청-함수-정의)
    - [2.3.1 게시물 관리](#231-게시물-관리)
    - [2.3.2 사용자 관리](#232-사용자-관리)
    - [2.3.3 파일 업로드](#233-파일-업로드)
  - [2.4 게시물 목록](#24-게시물-목록)
    - [2.4.1 게시물 목록 조회 기능 구현](#241-게시물-목록-조회-기능-구현)
    - [2.4.2 스켈레톤 UI 추가](#242-스켈레톤-ui-추가)
    - [2.4.3 html 정리](#243-html-정리)
    - [2.4.4 게시물 목록 조회 테스트](#244-게시물-목록-조회-테스트)
  - [2.5 게시물 상세](#25-게시물-상세)
    - [2.5.1 게시물 상세 조회 기능 구현](#251-게시물-상세-조회-기능-구현)
    - [2.5.2 html 정리](#252-html-정리)
    - [2.5.3 게시물 상세 조회 테스트](#253-게시물-상세-조회-테스트)
  - [2.6 회원 가입](#26-회원-가입)
    - [2.6.1 회원 가입 기능 구현](#261-회원-가입-기능-구현)
    - [2.6.2 회원 가입 테스트](#262-회원-가입-테스트)
  - [2.7 로그인](#27-로그인)
    - [2.7.1 JWT](#271-jwt)
    - [2.7.2 accessToken 관리 함수 작성](#272-accesstoken-관리-함수-작성)
    - [2.7.3 API 요청에 accessToken 추가](#273-api-요청에-accesstoken-추가)
    - [2.7.4 로그인 기능 구현](#274-로그인-기능-구현)
    - [2.7.5 로그인 테스트](#275-로그인-테스트)
  - [2.8 게시물 등록](#28-게시물-등록)
    - [2.8.1 게시물 등록 기능 구현](#281-게시물-등록-기능-구현)
    - [2.8.2 게시물 등록 테스트](#282-게시물-등록-테스트)
  - [2.9 게시물 수정](#29-게시물-수정)
    - [2.9.1 본인 게시물에만 수정, 삭제 버튼 노출](#291-본인-게시물에만-수정-삭제-버튼-노출)
    - [2.9.2 게시물 내용 출력](#292-게시물-내용-출력)
    - [2.9.3 게시물 수정 기능 구현](#293-게시물-수정-기능-구현)
    - [2.9.4 html 정리](#294-html-정리)
    - [2.9.5 게시물 수정 테스트](#295-게시물-수정-테스트)
  - [2.10 게시물 삭제](#210-게시물-삭제)
    - [2.10.1 게시물 삭제 기능 구현](#2101-게시물-삭제-기능-구현)
    - [2.10.2 게시물 삭제 테스트](#2102-게시물-삭제-테스트)
  - [2.11 라이언 보드 v02 완성](#211-라이언-보드-v02-완성)

- [3. Step 03 - 추가 기능 구현](#3-step-03---추가-기능-구현)
  - [3.1 type 정의](#31-type-정의)
    - [3.1.1 댓글 타입 정의](#311-댓글-타입-정의)
  - [3.2 API 요청 함수 정의](#32-api-요청-함수-정의)
    - [3.2.1 댓글 관리](#321-댓글-관리)
  - [3.3 댓글 목록 조회](#33-댓글-목록-조회)
    - [3.3.1 댓글 목록 조회 기능 구현](#331-댓글-목록-조회-기능-구현)
    - [3.3.2 html 정리](#332-html-정리)
    - [3.3.3 댓글 목록 조회 테스트](#333-댓글-목록-조회-테스트)
  - [3.4 댓글 등록](#34-댓글-등록)
    - [3.4.1 댓글 등록 기능 구현](#341-댓글-등록-기능-구현)
    - [3.4.2 댓글 등록 테스트](#342-댓글-등록-테스트)
  - [3.5 댓글 삭제](#35-댓글-삭제)
    - [3.5.1 댓글 삭제 기능 구현](#351-댓글-삭제-기능-구현)
    - [3.5.2 댓글 삭제 테스트](#352-댓글-삭제-테스트)
  - [3.6 게시물 검색](#36-게시물-검색)
    - [3.6.1 검색 기능 구현](#361-검색-기능-구현)
    - [3.6.2 검색 테스트](#362-검색-테스트)
  - [3.7 게시물 목록 pagination](#37-게시물-목록-pagination)
    - [3.7.1 pagination 기능 구현](#371-pagination-기능-구현)
    - [3.7.2 html 정리](#372-html-정리)
    - [3.7.3 pagination 테스트](#373-pagination-테스트)
  - [3.8 로그인 만료시 재 로그인 처리](#38-로그인-만료시-재-로그인-처리)
    - [3.8.1 로그인 만료 처리](#381-로그인-만료-처리)
    - [3.8.2 accessToken 재발행](#382-accesstoken-재발행)
    - [3.8.3 accessToken 재발행 구현](#383-accesstoken-재발행-구현)
    - [3.8.4 accessToken 재발행 테스트](#384-accesstoken-재발행-테스트)
    - [3.8.5 로그인하지 않은 상태로 글작성 테스트](#385-로그인하지-않은-상태로-글작성-테스트)
  - [3.9 자유게시판, 질문게시판](#39-자유게시판-질문게시판)
    - [3.9.1 자유게시판, 질문게시판 기능 구현](#391-자유게시판-질문게시판-기능-구현)
    - [3.9.2 게시판 링크 테스트](#392-게시판-링크-테스트)

## 개발 준비
- [2장 프로젝트 생성에서 배포까지](./02.start.md)까지 진행

### DB 초기화 및 API 서버 테스트 준비
- API 서버가 사용하는 DB에 데이터 일부를 미리 추가해 두어야 API를 원활히 사용할 수 있으므로 이를 위해 초기화 스크립트를 실행

#### DB 초기화 파일 다운로드

- 프로젝트 루트 폴더에서 실행하면 api/dbinit/board 폴더에 DB 초기화 파일이 다운로드 됨

- DB 초기화 파일 다운로드(게시판)
  + --force 옵션: 이전에 다운로드한 파일을 덮어씌움

  ```sh
  npx degit https://github.com/FEBC-API/APIServer/api/dbinit/board api/dbinit/board --force
  ```

#### 샘플 Bruno 파일 다운로드

- 프로젝트 루트 폴더에서 실행하면 api/bruno/board 폴더에 다운로드 됨

- 샘플 Bruno 파일 다운로드(게시판)

  ```sh
  npx degit https://github.com/FEBC-API/APIServer/api/bruno/board api/bruno/board --force
  ```

- Bruno > Collection > Open Collection 메뉴에서 다운로드한 api/bruno/board 컬렉션 추가
- [DB 초기화 API](https://fesp-api.koyeb.app/market/apidocs/#/%EC%8B%9C%EC%8A%A4%ED%85%9C/post_db_init) 작업 실행
  + 여러 사람이 같이 사용하는 DB이므로 꼭 필요할때만 초기화 작업 실행
- 필요하다면 Bruno에 추가한 sample-board 컬렉션 이용해서 API 테스트 진행

### 불필요한 파일 정리
* 프로젝트 루트의 index.html, public, src 삭제

  ```sh
  rm -rf index.html public src
  ```

### 샘플 코드 복사
* project-vanilla-lionboard 레포지토리에서 sample 폴더 다운로드(프로젝트 루트에서 실행)
  ```sh
  npx degit https://github.com/FEBC-15/project-vanilla-lionboard/sample sample
  ```

* 다운로드한 sample/lion-board 하위 모든 파일을 프로젝트에 복사
  ```sh
  cp -r sample/lion-board/* .
  ```

### vite.config.js 파일 수정
- 프로젝트 루트의 vite.config.js 파일에 나머지 url 등록
```js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        // 메인 페이지
        index: 'index.html',

        // 사용자 관련
        'user/login': 'src/pages/user/login.html',
        'user/signup': 'src/pages/user/signup.html',
        
        // 게시판 관련
        'board/list': 'src/pages/board/list.html',
        'board/new': 'src/pages/board/new.html',
        'board/detail': 'src/pages/board/detail.html',
        'board/edit': 'src/pages/board/edit.html',
        
        // 에러 페이지
        error: 'src/pages/error.html',
      },
    },
  },
  appType: 'mpa', // fallback 사용안함
});
```

### 샘플 코드 테스트
#### Vite 개발 서버 구동
```sh
npm run dev
```

#### 접속 테스트
* 개발 서버 구동 후 나오는 안내 메시지에 따라서 접속한 후 화면 테스트
  - 예시, http://localhost:5173

# 1. Step 01 - Web Components로 공용 HTML 코드 분리
- 여러 페이지에서 공용으로 사용할 HTML 코드를 컴포넌트로 개발

## 1.1 Web Components란?

- Web Components는 웹 표준 기술로, 재사용 가능한 커스텀 HTML 요소를 만들 수 있게 해주는 기술
- 프레임워크 없이도 컴포넌트 기반 개발을 할 수 있게 해주며, 다음과 같은 핵심 기술로 구성됨

### 1.1.1 주요 기술
- Custom Elements: 사용자 정의 HTML 요소를 정의할 수 있는 API
- Shadow DOM: 스타일과 마크업을 캡슐화하여 외부 스타일의 영향을 받지 않도록 함
- HTML Templates: 재사용 가능한 HTML 마크업을 정의 (`<template>`, `<slot>`)
- ES Modules: 모듈 시스템을 통한 컴포넌트 관리

### 1.1.2 Web Components의 장점
- 프레임워크 독립적: React, Vue 등 프레임워크 없이도 사용 가능
- 재사용성: 한 번 작성한 컴포넌트를 여러 프로젝트에서 재사용 가능
- 캡슐화: Shadow DOM을 통해 스타일과 구조가 격리됨
- 표준 기술: 브라우저 네이티브 지원으로 추가 라이브러리 불필요

### 1.1.3 기본 구조
- 컴포넌트 작성
```js
// my-component.js
class MyComponent extends HTMLElement {
  // 웹 컴포넌트가 DOM에 연결될 때 호출되는 메서드
  // 초기화, 컴포넌트 렌더링과 이벤트 등록
  connectedCallback() {
    this.render();
  }

  // UI를 렌더링
  private render() {
    this.innerHTML = '<p>MyComponent 내용입니다.</p>';
  }
}

customElements.define('lion-header', MyComponent);
```

- html 파일에서 `<lion-header>` 태그로 Header 컴포넌트 사용
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Components 예제</title>
  <script type="module" src="./my-component.js"></script>
</head>
<body>
  <h1>Web Components 사용 예제</h1>
  <lion-header></lion-header>
</body>
</html>
```

- 렌더링 결과
```html
...
<body>
  <h1>Web Components 사용 예제</h1>
  <lion-header>
    <p>MyComponent 내용입니다.</p>
  </lion-header>
</body>
...
```

## 1.2 프로젝트에 Web Components 적용
### 1.2.1 User 인터페이스 정의
- src/types/user.ts 작성
```ts
/**
 * 회원 관련 타입 정의
 */

// 회원 기본 정보
export interface User {
  _id: number;
  email: string;
  name: string;
  image?: string;
}

// 회원 유형 타입
export type UserType = 'user' | 'seller' | 'admin';

// 회원 가입 요청
export interface CreateUserRequest extends Omit<User, '_id'> {
  type: UserType;
  password: string;
}

// 회원 정보 조회
export interface UserDetail extends User {
  token: {
    accessToken: string;
    refreshToken?: string;
  };
}
```

### 1.2.2 컴포넌트 작성
#### Header 컴포넌트
- src/components/Header.ts
```ts
import type { User } from '../types/user';

/**
 * 헤더 웹 컴포넌트
 * 사이트 상단 네비게이션 바 렌더링 및 사용자 인증 상태에 따른 UI 변경
 */
class HeaderComponent extends HTMLElement {
  /**
   * 웹 컴포넌트가 DOM에 연결될 때 호출되는 생명주기 메서드
   * 컴포넌트 렌더링과 이벤트 초기화 수행
   */
  connectedCallback() {
    this.render();
    this.initEvent();
  }

  /**
   * 헤더 UI 렌더링
   * 사용자 로그인 상태에 따라 로그인/회원가입 버튼 또는 사용자 정보와 로그아웃 버튼 표시
   */
  private render() {
    const user = this.getUserData();
    // index.html의 <header> 태그를 복사해서 수정
    this.innerHTML = `
      <header class="px-8 min-w-80 bg-slate-100 dark:bg-gray-600 text-gray-800 dark:text-gray-200 transition-color duration-500 ease-in-out">
        <nav class="flex flex-wrap justify-center items-center p-4 md:flex-nowrap md:justify-between">
          <div class="w-1/2 order-1 md:w-auto">
            <a href="/" class="flex items-center gap-2">
              <img class="mr-3 h-6 w-auto sm:h-9" src="/assets/images/favicon.svg" width="24" height="24" alt="로고 이미지" />
              <span class="text-lg font-bold">라이언 보드</span>
            </a>
          </div>
          <div class="w-auto order-2 text-base mt-4 md:mt-0">
            <ul class="flex items-center gap-6 uppercase">
              <li class="hover:text-amber-500 hover:font-semibold"><a href="/src/pages/board/list?type=info">정보공유</a></li>
              <li class="hover:text-amber-500 hover:font-semibold"><a href="/src/pages/board/list?type=free">자유게시판</a></li>
              <li class="hover:text-amber-500 hover:font-semibold"><a href="/src/pages/board/list?type=qna">질문게시판</a></li>
            </ul>
          </div>

          <div class="w-1/2 order-1 flex justify-end items-center md:order-2 md:w-auto">

          ${ user.name ? `
            <form id="logout-form" action="/">
              <p class="flex items-center">
                ${user.image ? 
                  `<img 
                    class="w-8 rounded-full mr-2" 
                    src="${user.image}"
                    alt="${user.name} 프로필 이미지" />
                  ${user.name}님 :)
                ` : ``}
                <button type="submit" class="bg-gray-900 py-1 px-2 text-sm text-white font-semibold ml-2 hover:bg-amber-400 rounded">로그아웃</button>
              </p>
            </form>
          ` : `
            <div class="flex justify-end">
              <a href="/src/pages/user/login" class="bg-orange-500 py-1 px-2 text-sm text-white font-semibold ml-2 hover:bg-amber-400 rounded">로그인</a>
              <a href="/src/pages/user/signup" class="bg-gray-900 py-1 px-2 text-sm text-white font-semibold ml-2 hover:bg-amber-400 rounded">회원가입</a>
            </div>
          `}
            <button
              type="button"
              data-toggle-dark="dark"
              class="ml-4 flex items-center w-8 h-8 justify-center text-xs font-medium text-gray-700 bg-white border border-gray-200 rounded-lg toggle-dark-state-example hover:bg-gray-100 hover:text-blue-700 focus:z-10 focus:ring-2 focus:ring-gray-300 dark:focus:ring-gray-500 dark:bg-gray-800 focus:outline-none dark:text-gray-400 dark:border-gray-600 dark:hover:text-white dark:hover:bg-gray-700"
            >
              <svg
                data-toggle-icon="moon"
                class="w-3.5 h-3.5 hidden"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="currentColor"
                viewBox="0 0 18 20"
              >
                <path d="M17.8 13.75a1 1 0 0 0-.859-.5A7.488 7.488 0 0 1 10.52 2a1 1 0 0 0 0-.969A1.035 1.035 0 0 0 9.687.5h-.113a9.5 9.5 0 1 0 8.222 14.247 1 1 0 0 0 .004-.997Z"></path>
              </svg>
              <svg
                data-toggle-icon="sun"
                class="w-3.5 h-3.5"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path d="M10 15a5 5 0 1 0 0-10 5 5 0 0 0 0 10Zm0-11a1 1 0 0 0 1-1V1a1 1 0 0 0-2 0v2a1 1 0 0 0 1 1Zm0 12a1 1 0 0 0-1 1v2a1 1 0 1 0 2 0v-2a1 1 0 0 0-1-1ZM4.343 5.757a1 1 0 0 0 1.414-1.414L4.343 2.929a1 1 0 0 0-1.414 1.414l1.414 1.414Zm11.314 8.486a1 1 0 0 0-1.414 1.414l1.414 1.414a1 1 0 0 0 1.414-1.414l-1.414-1.414ZM4 10a1 1 0 0 0-1-1H1a1 1 0 0 0 0 2h2a1 1 0 0 0 1-1Zm15-1h-2a1 1 0 1 0 0 2h2a1 1 0 0 0 0-2ZM4.343 14.243l-1.414 1.414a1 1 0 1 0 1.414 1.414l1.414-1.414a1 1 0 0 0-1.414-1.414ZM14.95 6.05a1 1 0 0 0 .707-.293l1.414-1.414a1 1 0 1 0-1.414-1.414l-1.414 1.414a1 1 0 0 0 .707 1.707Z"></path>
              </svg>
              <span class="sr-only">Toggle dark/light mode</span>
            </button>

          </div>
        </nav>
      </header>
    `;
  }

  /**
   * localStorage에서 사용자 데이터 조회
   * @returns {User} 사용자 정보 객체 (없을 경우 빈 객체)
   */
  private getUserData(): User {
    let user: User = JSON.parse(localStorage.getItem('user') || '{}');
    return user;
  }

  /**
   * 헤더 내부의 이벤트 리스너 초기화
   * 로그아웃 폼 제출 이벤트 등록
   */
  private initEvent(){
    this.querySelector('#logout-form')?.addEventListener('submit', this.handleLogout.bind(this)) || null;
  }

  /**
   * 로그아웃 처리
   * localStorage에서 사용자 정보 제거 및 헤더 리렌더링
   */
  private handleLogout() {
    localStorage.removeItem('user');
    this.render();
  }

}

// HeaderComponent를 '<lion-header>' 태그명으로 등록
customElements.define('lion-header', HeaderComponent);
```

#### Footer 컴포넌트
- src/components/Footer.ts
```ts
/**
 * 푸터 웹 컴포넌트
 * 사이트 하단 정보 렌더링
 */
class FooterComponent extends HTMLElement {
  /**
   * 웹 컴포넌트가 DOM에 연결될 때 호출되는 생명주기 메서드
   * 컴포넌트 렌더링과 이벤트 초기화 수행
   */
  connectedCallback() {
    this.render();
  }

  /**
   * 푸터 UI 렌더링
   */
  private render() {
    // index.html의 <footer> 태그 복사
    this.innerHTML = `
      <footer class="p-4 pb-12 w-full border-t border-t-slate-200  dark:border-t-slate-500 dark:bg-gray-600 text-gray-600 dark:text-white transition-color duration-500 ease-in-out">
        <div class="min-w-[320px] flex flex-wrap gap-4 justify-center items-center text-sm text-slate-400">
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">약관</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">게시판 정책</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">회사소개</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">광고</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">마이비즈니스</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">제휴 제안</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">이용약관</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">개인정보취급방침</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">청소년보호 정책</a>
          <a href="/" class="hover:font-semibold dark:hover:text-gray-200">고객센터</a>
        </div>
      </footer>
    `;
  }

}

// FooterComponent를 '<lion-footer>' 태그명으로 등록
customElements.define('lion-footer', FooterComponent);
```

### 1.2.3 컴포넌트 적용
#### Header, Footer 컴포넌트 로딩

```
project-vanilla-sample/
├── index.html                ./src/components/Header.ts
└── src/
    └── pages/
        ├── board/
        │   ├── detail.html   ../../components/Header.ts
        │   ├── edit.html     ../../components/Header.ts
        │   ├── list.html     ../../components/Header.ts
        │   └── new.html      ../../components/Header.ts
        ├── user/
        │   ├── login.html    ../../components/Header.ts
        │   └── signup.html   ../../components/Header.ts
        └── error.html        ../components/Header.ts
```

- index.html
```html
<head>
  ...
  <script type="module" src="./src/components/Header.ts"></script>
  <script type="module" src="./src/components/Footer.ts"></script>
  <script type="module" src="./src/main.ts"></script>
</head>
```

- error.html
```html
<head>
  ...
  <script type="module" src="../components/Header.ts"></script>
  <script type="module" src="../components/Footer.ts"></script>
  <script type="module" src="./error.ts"></script>
</head>
```

- detail.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./detail.ts"></script>
</head>
```

- edit.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./edit.ts"></script>
</head>
```

- list.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./list.ts"></script>
</head>
```

- new.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./new.ts"></script>
</head>
```

- login.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./login.ts"></script>
</head>
```

- signup.html
```html
<head>
  ...
  <script type="module" src="../../components/Header.ts"></script>
  <script type="module" src="../../components/Footer.ts"></script>
  <script type="module" src="./signup.ts"></script>
</head>
```

#### `<header>`, `<footer>`를 Header, Footer 컴포넌트로 변경
- 각 html 파일의 `<header>` 영역을 삭제하고 Header 컴포넌트로 변경
- 각 html 파일의 `<footer>` 영역을 삭제하고 Footer 컴포넌트로 변경

- 수정전
```html
<body>
  ...
  <header></header>
  <main>...<main>
  <footer>...</footer>
  ...
</body>
```

- 수정후
```html
<body>
  ...
  <lion-header></lion-header>
  <main>...<main>
  <lion-footer></lion-footer>
  ...
</body>
```

### 1.2.4 테스트
- Header.ts의 `라이언 보드`를 `라이언 보드 v01`로 수정
- Footer.ts의 `약관`을 `이용 약관`으로 수정
- 파일 수정 후 모든 페이지에 반영되는지 확인

## 1.3 라이언 보드 v01 완성
- 완성 코드 참고: https://github.com/FEBC-15/project-vanilla-lionboard/tree/main/src-v01

# 2. Step 02 - 기본 기능 구현(API 서버 연동)
- Header.ts의 `라이언 보드 v01`을 `라이언 보드 v02`로 수정

- 게시물 목록, 상세 기능 구현
- 회원가입, 로그인 기능 구현
- 게시물 등록, 수정, 삭제 기능 구현

## 2.1 type 정의

### 2.1.1 게시물 타입 정의
* src/types/post.ts 생성

```ts
/**
 * 게시글 관련 타입 정의
 */

import type { User } from './user';

// 게시글 정보 (기본 타입 - 모든 속성 포함)
export interface Post {
  _id: number;
  type: string;
  user: User;
  title: string;
  content: string;
  views: number;
  createdAt: string;
  updatedAt: string;
}

// 게시글 목록 조회용 (replies 제외)
export interface PostListItem extends Omit<Post, 'replies'> {
  
}

// 게시글 생성 요청
export interface CreatePostRequest extends Pick<Post, 'type' | 'title' | 'content'> {

}

// 게시글 수정 요청
export interface UpdatePostRequest extends Pick<Post, 'title' | 'content'> {

}

```

### 2.1.2 파일 업로드 타입 정의
* src/types/file.ts 작성

```ts
export interface FileInfo {
  name: string;
  path: string;
}
```

### 2.1.3 서버 응답 데이터 타입 정의
* src/types/api.ts 작성

```ts
/**
 * API 에러 응답
 */
export interface ApiError {
  /** 요청 실패 여부 (항상 0) */
  ok: 0;
  /** 에러 메시지 */
  message: string;
  /** 인증 관련 에러 타입 */
  errorName?: 'EmptyAuthorization' | 'TokenExpiredError' | 'JsonWebTokenError';
  /** 유효성 검사 에러 정보 (필드별 상세 에러) */
  errors?: {
    [key: string]: {
      /** 에러 타입 */
      type: string;
      /** 검증 실패한 값 */
      value: string;
      /** 에러 메시지 */
      msg: string;
      /** 에러 발생 위치 (body, query, params 등) */
      location: string;
    };
  }
}

/**
 * 페이지네이션 정보
 */
export interface Pagination {
  /** 현재 페이지 번호 (1부터 시작) */
  page: number;
  /** 페이지당 항목 수 */
  limit: number;
  /** 전체 항목 수 */
  total: number;
  /** 전체 페이지 수 */
  totalPages: number;
}

/**
 * 목록 조회 API 응답 타입
 * @template T 목록 항목의 타입
 * @example
 * // 성공 응답
 * { ok: 1, item: [...], pagination: {...} }
 * // 실패 응답
 * { ok: 0, message: "에러 메시지" }
 */
export type ListRes<T> = 
  | {
      /** 요청 성공 여부 (항상 1) */
      ok: 1;
      /** 조회된 항목 배열 */
      item: T[];
      /** 페이지네이션 정보 */
      pagination: Pagination;
    }
  | ApiError;

/**
 * 상세 조회 API 응답 타입
 * @template T 조회할 항목의 타입
 * @example
 * // 성공 응답
 * { ok: 1, item: {...} }
 * // 실패 응답
 * { ok: 0, message: "에러 메시지" }
 */
export type DetailRes<T> = 
  | {
      /** 요청 성공 여부 (항상 1) */
      ok: 1;
      /** 조회된 항목 */
      item: T;
    }
  | ApiError;
```

## 2.2 공통 함수 정의
### 2.2.1 Axios 요청 함수
- src/utils/axios.ts 작성

```ts
import axios, { AxiosError, type AxiosInstance } from 'axios';

const API_SERVER = 'https://fesp-api.koyeb.app/market';

/**
 * Axios 인스턴스를 생성하고 인터셉터를 설정하는 함수
 * 요청 인터셉터에서 공통 파라미터를 추가하고,
 * 응답 인터셉터에서 에러 처리 및 accessToken 재발행 로직을 처리합니다.
 * 
 * @function getAxios
 * @returns {AxiosInstance} 설정된 Axios 인스턴스
 */
export function getAxios(): AxiosInstance {
  const instance = axios.create({
    baseURL: API_SERVER, // 기본 URL
    timeout: 1000*5,
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
      'Client-Id': 'board',
    }
  });

  // 요청 인터셉터 추가하기
  instance.interceptors.request.use((config) => {
    // 요청이 전달되기 전에 필요한 공통 작업 수행
    config.params = {
      // delay: 1000,
      ...config.params, // 기존 쿼리스트링 복사
    };
    return config;
  }, async (error) => {
    // 공통 에러 처리

    return Promise.reject(error);
  });

  // 응답 인터셉터 추가하기
  instance.interceptors.response.use((response) => {
    console.log('정상 응답 인터셉터 호출', response);
    // 2xx 범위에 있는 상태 코드는 이 함수가 호출됨

    return response;
  }, (error) => {
    console.error('에러 응답 인터셉터 호출', error);
    // 2xx 외의 범위에 있는 상태 코드는 이 함수가 호출됨
    // 공통 에러 처리
    const errors = error.response?.data.errors;
    if(error.status === 422 && errors){
      for(const err in errors){
        const validationError = errors[err];
        // input이나 textarea에 에러 메시지 표시
        const element = document.querySelector(`input[name="${err}"] + .validation-error, textarea[name="${err}"] + .validation-error`);
        if(element){
          element.textContent = validationError.msg;
        }
      }
      // 에러 처리를 했으므로 에러를 반환하지 않음
      return Promise.resolve(error.response);
    }
    return Promise.reject(error);
  });

  return instance;
}

/**
 * Axios 에러를 처리하는 함수
 * AxiosError인 경우 서버의 에러 응답 메시지 출력
 * 그 외의 경우 일반 Error 메시지를 표시합니다.
 * 
 * @function handleAxiosError
 * @param {unknown} err - 처리할 에러 객체
 * @returns {void}
 */
export function handleAxiosError(err: unknown){
  if(err instanceof AxiosError){
    alert(err.response?.data.message || err.message);
  }else{
    alert((err as Error).message);
  }
}
```

## 2.3 API 요청 함수 정의

### 2.3.1 게시물 관리
- 게시물 목록 조회, 상세 조회, 생성, 수정, 삭제

#### src/apis/post.ts 작성

```ts
import type { ListRes, DetailRes } from "../types/api";
import type { Post, CreatePostRequest, UpdatePostRequest, Reply, CreateReplyRequest } from "../types/post";
import { getAxios, handleAxiosError } from "../utils/axios";

const axiosInstance = getAxios();

/**
 * 게시글 목록을 조회합니다.
 * @param params - 쿼리 파라미터 (페이지네이션, 필터링 등)
 * @returns 게시글 목록과 페이지네이션 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function getPostListApi(params: Record<string, string> = {}): Promise<ListRes<Post> | undefined> {
  try{
    const res = await axiosInstance.get<ListRes<Post>>('/posts', { params });
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 게시글을 상세 조회합니다.
 * @param id - 조회할 게시글의 ID
 * @returns 게시글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function getPostApi(id: string): Promise<DetailRes<Post> | undefined> {
  try{
    const res = await axiosInstance.get<DetailRes<Post>>(`/posts/${id}`);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 새로운 게시글을 생성합니다.
 * @param post - 생성할 게시글 정보
 * @returns 생성된 게시글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function createPostApi(post: CreatePostRequest): Promise<DetailRes<Post> | undefined> {
  try{
    const res = await axiosInstance.post<DetailRes<Post>>('/posts', post);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 게시글을 수정합니다.
 * @param id - 수정할 게시글의 ID
 * @param post - 수정할 게시글 정보
 * @returns 수정된 게시글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function updatePostApi(id: string, post: UpdatePostRequest): Promise<DetailRes<Post> | undefined> {
  try{
    const res = await axiosInstance.patch<DetailRes<Post>>(`/posts/${id}`, post);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 게시글을 삭제합니다.
 * @param id - 삭제할 게시글의 ID
 * @returns 삭제된 게시글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function deletePostApi(id: string): Promise<DetailRes<Post> | undefined> {
  try{
    const res = await axiosInstance.delete<DetailRes<Post>>(`/posts/${id}`);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}
```

### 2.3.2 사용자 관리

- 사용자 생성, 로그인

#### src/apis/user.ts 작성

```ts
import type { DetailRes } from "../types/api";
import type { CreateUserRequest, UserDetail } from "../types/user";
import { getAxios, handleAxiosError } from "../utils/axios";

const axiosInstance = getAxios();

/**
 * 새로운 사용자를 생성합니다.
 * @param user - 생성할 사용자 정보
 * @returns 생성된 사용자 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function createUserApi(user: CreateUserRequest): Promise<DetailRes<UserDetail> | undefined> {
  try{
    const res = await axiosInstance.post<DetailRes<UserDetail>>('/users', user);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 사용자 로그인을 수행합니다.
 * @param email - 사용자 이메일
 * @param password - 사용자 비밀번호
 * @returns 로그인된 사용자 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function loginUserApi(email: string, password: string): Promise<DetailRes<UserDetail> | undefined> {
  try{
    const res = await axiosInstance.post<DetailRes<UserDetail>>('/users/login', { email, password });
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}
```

### 2.3.3 파일 업로드

#### src/apis/file.ts 작성

```ts
import type { ListRes } from '../types/api';
import type { FileInfo } from '../types/file';
import { getAxios, handleAxiosError } from '../utils/axios';

const axiosInstance = getAxios();

/**
 * 파일 업로드 함수
 * @param formData - 업로드할 파일이 담긴 FormData 객체
 * @returns 파일 업로드 결과를 반환하는 Promise
 * @description
 * 파일을 서버에 업로드하고, 업로드된 파일 정보를 반환합니다.
 * API 참고: https://fesp-api.koyeb.app/market/apidocs/#/%ED%8C%8C%EC%9D%BC/post_files_
 */
export async function uploadFileApi(attachFile: File | File[]): Promise<ListRes<FileInfo> | undefined> {
  try{
    if(attachFile instanceof File){
      attachFile = [attachFile];
    }
    // 새로운 FormData 객체 생성 후 파일 추가
    const fileForm = new FormData();
    attachFile.forEach(file => {
      fileForm.append('attach', file);
    });
    const res = await axiosInstance.post<ListRes<FileInfo>>('/files', fileForm, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}
```

## 2.4 게시물 목록

### 2.4.1 게시물 목록 조회 기능 구현
#### src/pages/board/list.ts 수정
- listView, render 함수 작성 

```ts
import { getPostListApi } from "../../apis/post";
import type { Post } from "../../types/post";

/** 페이지당 게시글 개수 */
const LIMIT = '10';

/**
 * 게시글 목록을 조회하고 렌더링하는 함수
 * URL 쿼리 파라미터에서 type을 가져와 해당 타입의 게시글 목록을 표시합니다.
 * 기본값은 type='info'이며, LIMIT(10)개 게시글을 조회합니다.
 * 
 * @async
 * @function listView
 * @returns {Promise<void>}
 */
async function listView(){
  const type = new URLSearchParams(window.location.search).get('type') || 'info';
  const page = new URLSearchParams(window.location.search).get('page') || '1';
  const data = await getPostListApi({ type, page, limit: LIMIT });
  if(data?.ok){
    render(data.item);
  }
}

/**
 * 게시글 목록을 테이블 행으로 렌더링하는 함수
 * Post 배열을 받아서 각 게시글을 테이블 행(tr) HTML로 변환하고,
 * 페이지의 #list-container tbody 요소에 삽입합니다.
 * 
 * @function render
 * @param {Post[]} posts - 렌더링할 게시글 배열
 * @returns {void}
 */
function render(posts: Post[]) {
  const result = posts.map(post => {
    return `
      <tr class="border-b border-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700 transition duration-300 ease-in-out">
        <td class="p-2 text-center">${post._id}</td>
        <td class="p-2 truncate indent-4"><a href="detail?id=${post._id}&type=${post.type}" class="hover:text-orange-500 hover:underline">${post.title}</a></td>
        <td class="p-2 text-center truncate">${post.user.name}</td>
        <td class="p-2 text-center hidden sm:table-cell">${post.views}</td>
        <td class="p-2 truncate text-center hidden sm:table-cell">${post.createdAt}</td>
      </tr>
    `;
  });
  const tbody = document.querySelector('tbody');
  if (tbody) {
    tbody.innerHTML = result.join('');
  }
}

listView();
```

### 2.4.2 스켈레톤 UI 추가

- 스켈레톤 UI(서버에서 데이터를 받기 전에 보여줄 기본 UI)를 렌더링하는 함수

#### src/pages/board/list.ts 수정

- renderSkeleton 함수 추가

```ts
...

async function listView(){ ... }

function render(posts: Post[]) { ... }

/**
 * 게시글 목록 로딩 중 스켈레톤 UI를 렌더링하는 함수
 * LIMIT 개수만큼 스켈레톤 테이블 행을 생성하여 페이지의 tbody 요소에 삽입합니다.
 * 데이터 로딩 전에 사용자에게 로딩 상태를 시각적으로 표시합니다.
 * 
 * @function renderSkeleton
 * @returns {void}
 */
function renderSkeleton() {
  const skeletonRows = Array.from({ length: parseInt(LIMIT) }, () => {
    // list.html 파일에서 복사
    return `
      <tr class="border-b border-gray-200 animate-pulse">
        <td class="p-2 text-center"><div class="h-6 leading-normal bg-gray-300 dark:bg-gray-600 rounded mx-auto w-8"></div></td>
        <td class="p-2 truncate indent-4"><div class="h-6 leading-normal bg-gray-300 dark:bg-gray-600 rounded w-3/4"></div></td>
        <td class="p-2 text-center truncate"><div class="h-6 leading-normal bg-gray-300 dark:bg-gray-600 rounded mx-auto w-16"></div></td>
        <td class="p-2 text-center hidden sm:table-cell"><div class="h-6 leading-normal bg-gray-300 dark:bg-gray-600 rounded mx-auto w-12"></div></td>
        <td class="p-2 truncate text-center hidden sm:table-cell"><div class="h-6 leading-normal bg-gray-300 dark:bg-gray-600 rounded mx-auto"></div></td>
      </tr>
    `;
  }).join('');

  const tbody = document.querySelector('#list-container tbody');
  if (tbody) {
    tbody.innerHTML = skeletonRows;
  }
}

renderSkeleton();
listView();
```

### 2.4.3 html 정리
#### src/pages/board/list.html 수정

- `<tbody>` 하위에 더미 데이터 `<tr>` 태그 삭제

```html
...
<tbody>
  <!-- 게시물 목록 표시 영역 -->
</tbody>
...
```

### 2.4.4 게시물 목록 조회 테스트
- http://localhost:5173/src/pages/board/list?type=info

## 2.5 게시물 상세

### 2.5.1 게시물 상세 조회 기능 구현

#### src/pages/board/detail.ts 수정

- detailView, render 함수 작성

```ts
import { getPostApi } from "../../apis/post";
import type { Post } from "../../types/post";

/**
 * 게시글 상세 정보를 조회하고 렌더링하는 함수
 * URL 쿼리 파라미터에서 id를 가져와 해당 게시글의 상세 정보를 조회하고 표시합니다.
 * 
 * @async
 * @function detailView
 * @returns {Promise<void>}
 */
async function detailView(){
  const id = new URLSearchParams(window.location.search).get('id');
  if(id){
    const data = await getPostApi(id);
    if(data?.ok){
      render(data.item);
    }
  }
}

/**
 * 게시글 상세 정보를 DOM에 렌더링하는 함수
 * Post 객체를 받아서 제목, 작성자명, 수정일시, 내용을 각각의 DOM 요소에 삽입합니다.
 * 
 * @function render
 * @param {Post} post - 렌더링할 게시글 객체
 * @returns {void}
 */
function render(post: Post) {
  document.querySelector('#title')!.innerHTML = post.title;
  document.querySelector('#user-name')!.innerHTML = post.user.name;
  document.querySelector('#updated-at')!.innerHTML = post.updatedAt;
  document.querySelector('#content > p')!.innerHTML = post.content;
}

detailView();
```

### 2.5.2 html 정리

#### src/pages/board/detail.html 수정

- 더미 데이터인 게시물 제목, 작성자, 날짜, 내용 삭제
  - `React란?`
  - `액션핑`
  - `2025.10.29 14:00:00`
  - `React는 UI를 구성하기 위한 ...`

```html
...
<span id="title">
</span>
...
<div>작성자 : 
  <span id="user-name">
  </span>
</div>
...
<div id="updated-at">
</div>
...
<div id="content">
  <p class="w-full p-2 whitespace-pre-wrap">
  </p>
</div>
...
```

### 2.5.3 게시물 상세 조회 테스트
- http://localhost:5173/src/pages/board/detail?id=16&type=info

## 2.6 회원 가입

### 2.6.1 회원 가입 기능 구현

#### src/pages/user/signup.ts 작성
- signup, handleSubmit 함수 작성

```ts
import { uploadFileApi } from "../../apis/file";
import { createUserApi } from "../../apis/user";
import type { CreateUserRequest, UserType } from "../../types/user";

/**
 * 회원가입을 처리하는 함수
 * 폼 데이터에서 사용자 정보를 추출하고, 프로필 이미지가 있으면 업로드한 후
 * 사용자 생성 API를 호출합니다. 회원가입이 성공하면 메인 페이지로 이동합니다.
 * 
 * @async
 * @function signup
 * @param {HTMLFormElement} formElement - 회원가입 폼 요소
 * @returns {Promise<void>}
 */
async function signup(formElement: HTMLFormElement) {
  const formData = new FormData(formElement);

  // 첨부파일(프로필 이미지) 처리
  let image;
  const attachFile = formData.get('attach') as File;
  
  if(attachFile.size > 0){
    // 파일 업로드 API 호출
    const fileRes = await uploadFileApi(attachFile);
    console.log(`fileRes`, fileRes);
    if(fileRes?.ok){
      image = fileRes.item[0].path;
    }
  }

  const user: CreateUserRequest = {
    type: (formData.get('type') || 'user') as UserType ,
    email: formData.get('email') as string,
    name: formData.get('name') as string,
    password: formData.get('password') as string,
    image,
  };

  // 사용자 생성 API 호출
  const userData = await createUserApi(user);
  console.log(`userData`, userData);
  if(userData?.ok){
    alert('회원가입이 완료되었습니다.');
    location.href = '/'; // 메인 페이지로 이동
  }
}

/**
 * 폼 제출 이벤트를 처리하는 함수
 * 기본 제출 동작을 방지하고, 폼 데이터를 검증한 후
 * 검증이 통과하면 signup 함수를 호출하여 회원가입을 진행합니다.
 * 
 * @async
 * @function handleSubmit
 * @param {Event} event - 폼 제출 이벤트 객체
 * @returns {Promise<void>}
 */
async function handleSubmit(event: Event) {
  event.preventDefault(); // 브라우저 기본 동작 취소
  const formElement = event.target as HTMLFormElement;
  // 입력 데이터 검증
  const isValid = validateForm(formElement);
  if(isValid){
    await signup(formElement); // 회원가입 진행
  }  
}

/**
 * 폼 데이터 검증 함수
 * 이름, 이메일, 비밀번호 필드의 필수 입력 여부를 검증하고,
 * 검증 실패 시 오류 메시지를 표시합니다.
 * 
 * @function validateForm
 * @param {HTMLFormElement} formElement - 검증할 폼 요소
 * @returns {boolean} - 검증 통과 여부 (true: 통과, false: 실패)
 */
function validateForm(formElement: HTMLFormElement) {
  let result: boolean = true;

  const name = formElement.querySelector<HTMLInputElement>('[name=name]')!;
  const email = formElement.querySelector<HTMLInputElement>('[name=email]')!;
  const password = formElement.querySelector<HTMLInputElement>('[name=password]')!;

  if(password.value.trim() === ''){
    password.nextElementSibling!.textContent = '비밀번호는 필수입니다.';
    password.focus();
    result = false;
  }else{
    password.nextElementSibling!.textContent = '';
  }

  if(email.value.trim() === ''){
    email.nextElementSibling!.textContent = '이메일은 필수입니다.';
    email.focus();
    result = false;
  }else{
    email.nextElementSibling!.textContent = '';
  }

  if(name.value.trim() === ''){
    name.nextElementSibling!.textContent = '이름은 필수입니다.';
    name.focus();
    result = false;
  }else{
    name.nextElementSibling!.textContent = '';
  }

  return result;
}

document.querySelector('#signup-form')?.addEventListener('submit', handleSubmit);
```

### 2.6.2 회원 가입 테스트
- http://localhost:5173/src/pages/user/signup
  - 이름: 나무
  - 이메일: namu@board.com
  - 비밀번호: 11111111
  - 프로필 이미지: api/dbinit/board/uploadFiles/user-namu.png 선택
  - 회원가입 클릭

## 2.7 로그인

### 2.7.1 JWT
#### JWT 구조와 용도
- JWT(JSON Web Token)는 `header.payload.signature` 세 부분으로 이뤄진 토큰 포맷  
- payload에는 사용자 식별자, 만료 시각(`exp`), 발급 시각(`iat`) 같은 클레임을 담고 Base64Url로 인코딩
- 서명(signature)이 붙어 있으므로 서버 비밀키 없이 위조가 불가능하고, 클라이언트는 토큰만으로 인증 상태를 유지할 수 있음
- 로그인 한 사용자 정보를 담아두고 서버쪽에 사용자 인증을 위해 HTTP 요청시 Authorization 헤더에 첨부

#### accessToken, refreshToken 역할
- accessToken: 짧은 만료 시간을 갖고, HTTP Authorization 헤더에 `Bearer <token>` 형태로 넣어 API 요청 때마다 인증에 사용  
- refreshToken: 긴 만료 시간을 갖고 별도로 보관해 두었다가 accessToken 만료 시 새 accessToken 을 발급받을 때 사용  
- 두 토큰을 분리하면 accessToken 탈취 사고 범위를 줄이고, refreshToken 재발행 정책으로 추가 보안을 적용할 수 있음

### 2.7.2 accessToken 관리 함수 작성
- 로그인이 완료되면 응답받은 accessToken, refreshToken을 로컬 스토리지에 저장

#### src/utils/user.ts 작성
```ts
import type { UserDetail } from "../types/user";

/**
 * localStorage에서 사용자 정보를 가져오는 함수
 * 저장된 사용자 정보가 있으면 JSON 파싱하여 반환하고, 없으면 null을 반환합니다.
 * 
 * @function getUser
 * @returns {UserDetail | null} - 사용자 객체 또는 null
 */
export function getUser(): UserDetail | null {
  const user = localStorage.getItem('user');
  return user ? JSON.parse(user) : null;
}

/**
 * 사용자 정보를 localStorage에 저장하는 함수
 * 
 * @function setUser
 * @param {UserDetail} user - 저장할 사용자 객체
 * @returns {void}
 */
export function setUser(user: UserDetail): void {
  localStorage.setItem('user', JSON.stringify(user));
}

/**
 * localStorage에서 사용자 정보를 제거하는 함수
 * 
 * @function removeUser
 * @returns {void}
 */
export function removeUser(): void {
  localStorage.removeItem('user');
}
```

### 2.7.3 API 요청에 accessToken 추가

#### src/utils/axios.ts 파일 수정
```ts
import { getUser } from './user';

...

export function getAxios(): AxiosInstance {
const user = getUser();
  const instance = axios.create({
    baseURL: API_SERVER, // 기본 URL
    timeout: 1000*5,
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
      'Client-Id': 'board',
      Authorization: `Bearer ${user?.token?.accessToken}`,
    }
  });

  ...

}
```
### 2.7.4 로그인 기능 구현

#### src/pages/user/login.ts 작성

- login, handleSubmit, validateForm 함수 작성

```ts
import { loginUserApi } from "../../apis/user";
import type { UserDetail } from "../../types/user";
import { setUser } from "../../utils/user";

/**
 * 로그인을 처리하는 함수
 * 폼 데이터에서 이메일과 비밀번호를 추출하여 로그인 API를 호출하고,
 * 로그인이 성공하면 사용자 정보를 localStorage에 저장한 후 메인 페이지로 이동합니다.
 * 
 * @async
 * @function login
 * @param {HTMLFormElement} formElement - 로그인 폼 요소
 * @returns {Promise<void>}
 */
async function login(formElement: HTMLFormElement) {
  const formData = new FormData(formElement);
  const email = formData.get('email') as string;
  const password = formData.get('password') as string;
  const loginRes = await loginUserApi(email, password);
  if(loginRes?.ok){
    const user: UserDetail = {
      _id: loginRes.item._id,
      email: loginRes.item.email,
      name: loginRes.item.name,
      image: loginRes.item.image,
      token: loginRes.item.token,
    };
    setUser(user);
    alert('로그인이 완료되었습니다.');
    location.href = '/';
  }
}

/**
 * 폼 제출 이벤트를 처리하는 함수
 * 기본 제출 동작을 방지하고, 폼 데이터를 검증한 후
 * 검증이 통과하면 login 함수를 호출하여 로그인을 진행합니다.
 * 
 * @async
 * @function handleSubmit
 * @param {Event} event - 폼 제출 이벤트 객체
 * @returns {Promise<void>}
 */
async function handleSubmit(event: Event) {
  event.preventDefault();

  const formElement = event.target as HTMLFormElement;
  // 입력 데이터 검증
  const isValid = validateForm(formElement);
  if(isValid){
    await login(formElement); // 로그인 진행
  }
}

/**
 * 폼 데이터 검증 함수
 * 이메일, 비밀번호 필드의 필수 입력 여부를 검증하고,
 * 검증 실패 시 오류 메시지를 표시합니다.
 * 
 * @function validateForm
 * @param {HTMLFormElement} formElement - 검증할 폼 요소
 * @returns {boolean} - 검증 통과 여부 (true: 통과, false: 실패)
 */
function validateForm(formElement: HTMLFormElement) {
  let result: boolean = true;

  const email = formElement.querySelector<HTMLInputElement>('[name=email]')!;
  const password = formElement.querySelector<HTMLInputElement>('[name=password]')!;

  if(password.value.trim() === ''){
    password.nextElementSibling!.textContent = '비밀번호는 필수입니다.';
    password.focus();
    result = false;
  }else{
    password.nextElementSibling!.textContent = '';
  }

  if(email.value.trim() === ''){
    email.nextElementSibling!.textContent = '이메일은 필수입니다.';
    email.focus();
    result = false;
  }else{
    email.nextElementSibling!.textContent = '';
  }

  return result;
}

document.querySelector('#login-form')?.addEventListener('submit', handleSubmit);
```

### 2.7.5 로그인 테스트
#### 로그인
- http://localhost:5173/src/pages/user/login
  - 이메일: jayg@board.com
  - 비밀번호: 11111111
  - 로그인 클릭

#### 로그인 완료후 사용자 정보 확인
- header 영역에 로그인, 회원가입 버튼이 로그인한 사용자의 이름, 로그아웃 버튼으로 바뀌는지 확인

#### API 요청헤더에 accessToken 전달 확인
- 브라우저의 개발자도구 > 네트워크 탭을 열고 게시물 상세조회 실행
- 게시물 상세조회 API 요청 정보를 선택한 후 Headers 탭에서 Request Headers 영역에 Authorization 헤더가 `Bearer xxx` 형태로 전달되는지 확인

## 2.8 게시물 등록
### 2.8.1 게시물 등록 기능 구현

#### src/pages/board/new.ts 작성
- createPost, handleSubmit 함수 작성

```ts
import { createPostApi } from "../../apis/post";
import type { CreatePostRequest } from "../../types/post";

/**
 * 게시글을 생성하는 비동기 함수
 * URL 쿼리 파라미터에서 게시판 타입을 가져오고,
 * 폼 데이터를 수집하여 API를 호출합니다.
 * 생성 성공 시 해당 게시판 목록 페이지로 이동합니다.
 */
async function createPost() {
  const type = new URLSearchParams(window.location.search).get('type');
  const formData = new FormData(document.querySelector<HTMLFormElement>('#new-form')!);
  const post: CreatePostRequest = {
    type: type || 'info',
    title: formData.get('title') as string,
    content: formData.get('content') as string,
  };
  const postRes = await createPostApi(post);
  if(postRes?.ok){  
    alert('게시글이 등록되었습니다.');
    location.href = `list?type=${type}`;
  }
}

/**
 * 폼 제출 이벤트 핸들러
 * 기본 폼 제출 동작을 막고, 유효성 검사 에러 메시지를 초기화한 후
 * 게시글 생성 함수를 호출합니다.
 * @param event - 폼 제출 이벤트 객체
 */
async function handleSubmit(event: Event) {
  event.preventDefault();
  const formElement = event.target as HTMLFormElement;
  const isValid = validateForm(formElement);
  if(isValid){
    createPost();
  }
}

/**
 * 폼 유효성 검사 함수
 * 폼 데이터를 검사하여 유효성 검사 에러 메시지를 초기화한 후
 * 게시글 생성 함수를 호출합니다.
 * @param formElement - 폼 요소
 * @returns {boolean} - 유효성 검사 결과
 */
function validateForm(formElement: HTMLFormElement): boolean {
  let result: boolean = true;

  const title = formElement.querySelector<HTMLInputElement>('[name=title]')!;
  const content = formElement.querySelector<HTMLTextAreaElement>('[name=content]')!;

  if(content.value.trim() === ''){
    content.nextElementSibling!.textContent = '내용은 필수입니다.';
    content.focus();
    result = false;
  }else{
    content.nextElementSibling!.textContent = '';
  }
  
  if(title.value.trim() === ''){
    title.nextElementSibling!.textContent = '제목은 필수입니다.';
    title.focus();
    result = false;
  }else{
    title.nextElementSibling!.textContent = '';
  }
  return result;
}

document.querySelector('#new-form')?.addEventListener('submit', handleSubmit);
```

### 2.8.2 게시물 등록 테스트
- http://localhost:5173/src/pages/board/new?type=info

## 2.9 게시물 수정

### 2.9.1 본인 게시물에만 수정, 삭제 버튼 노출

#### src/pages/board/detail.ts에 추가

- renderButtons 함수 작성
- render 함수 수정

```ts
function render(post: Post) {
  ...
  renderButtons(post);
}

/**
 * 게시글 상세 페이지의 버튼들을 렌더링하는 함수
 * 목록 버튼은 항상 표시하며, 로그인한 사용자가 게시글 작성자인 경우에만 수정/삭제 버튼을 추가로 표시합니다.
 * 
 * @function renderButtons
 * @param {Post} post - 버튼을 렌더링할 게시글 객체
 * @returns {void}
 */
function renderButtons(post: Post) {
  // detail.html 파일에서 복사 후 수정
  let buttonContent = `<a href="list?type=${post.type}" class="bg-orange-500 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">목록</a>`;
  const user = getUser();
  // 로그인한 사용자 id와 게시물 작성자 id가 일치할 경우 수정, 삭제 버튼 추가
  if(user?._id === post.user._id){
    // detail.html 파일에서 복사 후 수정
    buttonContent += `
      <a href="edit?id=${post._id}&type=${post.type}" class="bg-gray-900 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">수정</a>
      <button type="submit" class="bg-red-500 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">삭제</button>
    `;
  }
  
  document.querySelector('#button-container')!.innerHTML = buttonContent;
}
```

#### src/pages/board/detail.html 수정

- 더미 데이터인 목록, 수정, 삭제 버튼 제거

- 제거 전
```html
<div id="button-container" class="flex justify-end my-4">
  <a href="list?type=info" class="bg-orange-500 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">목록</a>
  <a href="edit?id=1&type=info" class="bg-gray-900 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">수정</a>
  <button type="submit" class="bg-red-500 py-1 px-4 text-base text-white font-semibold ml-2 hover:bg-amber-400 rounded">삭제</button>
</div>
```

- 제거 후
```html
<div id="button-container" class="flex justify-end my-4"></div>
```

#### 테스트
- 로그인 한 사용자의 게시글에만 수정, 삭제 버튼이 보이는지 확인

### 2.9.2 게시물 내용 출력

#### src/pages/board/edit.ts 수정
- editView, render 함수 작성

```ts
import { getPostApi, updatePostApi } from "../../apis/post";
import type { Post, UpdatePostRequest } from "../../types/post";

/**
 * 게시글 수정 페이지 초기화 함수
 * URL 쿼리 파라미터에서 id를 가져와 해당 게시글의 정보를 조회하고 폼에 렌더링합니다.
 * 
 * @async
 * @function editView
 * @returns {Promise<void>}
 */
async function editView(){
  const id = new URLSearchParams(window.location.search).get('id');
  if(id){
    const data = await getPostApi(id);
    if(data?.ok){
      render(data.item);
    }
  }
}

/**
 * 게시글 정보를 폼에 렌더링하는 함수
 * Post 객체를 받아서 제목과 내용을 각각의 입력 필드에 설정합니다.
 * 
 * @function render
 * @param {Post} post - 폼에 렌더링할 게시글 객체
 * @returns {void}
 */
function render(post: Post) {
  const title = document.querySelector<HTMLInputElement>('#title');
  if(title){
    title.value = post.title;
  }
  
  const content = document.querySelector<HTMLTextAreaElement>('#content');
  if(content){
    content.value = post.content;
  }
}
  
// 페이지 로드 시 게시글 정보 조회 및 폼 렌더링
editView();
```

### 2.9.3 게시물 수정 기능 구현

#### src/pages/board/edit.ts에 추가
- updatePost, validateForm, handleSubmit 함수 추가

```ts
...

/**
 * 게시글을 업데이트하는 함수
 * 폼에서 입력된 제목과 내용을 가져와 서버에 업데이트 요청을 보냅니다.
 * 업데이트가 성공하면 알림을 표시하고 게시글 상세 페이지로 이동합니다.
 * 
 * @async
 * @function updatePost
 * @returns {Promise<void>}
 */
async function updatePost() {
  const id = new URLSearchParams(window.location.search).get('id');
  const type = new URLSearchParams(window.location.search).get('type');
  if(id){
    const form = document.querySelector<HTMLFormElement>('#edit-form');
    const formData = new FormData(form!);
    const post: UpdatePostRequest = {
      title: formData.get('title') as string,
      content: formData.get('content') as string,
    };
    const data = await updatePostApi(id, post);
    if(data?.ok){
      alert('게시글이 수정되었습니다.');
      location.href = `detail?id=${id}&type=${type}`;
    }
  }
}

/**
 * 폼 유효성 검증 함수
 * 제목과 내용 필드가 비어있지 않은지 검증합니다.
 * 유효하지 않은 필드가 있으면 에러 메시지를 표시하고 해당 필드에 포커스를 설정합니다.
 * 
 * @function validateForm
 * @param {HTMLFormElement} formElement - 검증할 폼 요소
 * @returns {boolean} - 폼이 유효하면 true, 그렇지 않으면 false
 */
function validateForm(formElement: HTMLFormElement): boolean {
  let result: boolean = true;

  const title = formElement.querySelector<HTMLInputElement>('[name=title]')!;
  const content = formElement.querySelector<HTMLTextAreaElement>('[name=content]')!;

  // 내용 필드 검증
  if(content.value.trim() === ''){
    content.nextElementSibling!.textContent = '내용은 필수입니다.';
    content.focus();
    result = false;
  }else{
    content.nextElementSibling!.textContent = '';
  }
  
  // 제목 필드 검증
  if(title.value.trim() === ''){
    title.nextElementSibling!.textContent = '제목은 필수입니다.';
    title.focus();
    result = false;
  }else{
    title.nextElementSibling!.textContent = '';
  }
  return result;
}

/**
 * 폼 제출 이벤트 핸들러
 * 폼 제출 시 기본 동작을 막고, 유효성 검증을 수행한 후 유효한 경우에만 게시글을 업데이트합니다.
 * 
 * @async
 * @function handleSubmit
 * @param {Event} event - 폼 제출 이벤트
 * @returns {Promise<void>}
 */
async function handleSubmit(event: Event) {
  event.preventDefault();

  const formElement = event.target as HTMLFormElement;
  const isValid = validateForm(formElement);
  if(isValid){
    updatePost();
  }
}

// 폼 제출 이벤트 리스너 등록
document.querySelector('#edit-form')?.addEventListener('submit', handleSubmit);
```

### 2.9.4 html 정리

#### src/pages/board/edit.html 수정

- 더미 데이터인 게시물 제목 삭제
  - `<input id="title" ... />` 요소의 value 속성 삭제

- 더미 데이터인 게시물 내용 삭제
  - `<textarea id="content" ... /></textarea>` 요소의 `React는...` 문자열 삭제

### 2.9.5 게시물 수정 테스트
- http://localhost:5173/src/pages/board/detail?id=21&type=info

## 2.10 게시물 삭제

### 2.10.1 게시물 삭제 기능 구현

#### src/pages/board/detail.ts에 추가
- handleDeletePost 함수 작성

```ts
import { deletePostApi } from "../../apis/post";

...

/**
 * 게시글 삭제 이벤트 핸들러
 * 폼 제출 시 기본 동작을 막고, URL 쿼리 파라미터에서 게시글 ID를 가져와 삭제 요청을 보냅니다.
 * 삭제가 성공하면 알림을 표시하고 게시글 목록 페이지로 이동합니다.
 * 
 * @async
 * @function handleDeletePost
 * @param {Event} event - 폼 제출 이벤트
 * @returns {Promise<void>}
 */
async function handleDeletePost(event: Event) {
  event.preventDefault();
  if(confirm('게시글을 삭제하시겠습니까?')){
    const searchParams = new URLSearchParams(window.location.search);
    const id = searchParams.get('id');
    const type = searchParams.get('type');
    if(id){
      const data = await deletePostApi(id);
      if(data?.ok){
        alert('게시글이 삭제되었습니다.');
        location.href = `list?type=${type}`;
      }
    }
  }
}

document.querySelector('#detail-form')?.addEventListener('submit', handleDeletePost);
```

### 2.10.2 게시물 삭제 테스트
- http://localhost:5173/src/pages/board/detail?id=21&type=info

## 2.11 라이언 보드 v02 완성
- 완성 코드 참고: https://github.com/FEBC-15/project-vanilla-lionboard/tree/main/src-v02

# 3. Step 03 - 추가 기능 구현
- Header.ts의 `라이언 보드 v02`를 `라이언 보드 v03`으로 수정

- 댓글 목록 조회, 등록, 삭제 기능 구현
- 검색 기능 구현
- 게시물 목록의 pagination 기능 구현
- accessToken 재발행
- 자유게시판, 질문게시판 기능 구현

## 3.1 type 정의

### 3.1.1 댓글 타입 정의
* src/types/post.ts에 추가

```ts

...

// 댓글 정보 (기본 타입 - 모든 속성 포함)
export interface Reply {
  _id: number;
  user: User;
  content: string;
  createdAt: string;
  updatedAt: string;
}

// 댓글 생성 요청
export interface CreateReplyRequest extends Pick<Reply, 'content'> {
  
}
```

## 3.2 API 요청 함수 정의

### 3.2.1 댓글 관리
- 댓글 목록 조회, 생성, 삭제

#### src/apis/post.ts에 추가

```ts
...

/**
 * 게시글의 댓글 목록을 조회합니다.
 * @param id - 댓글을 조회할 게시글의 ID
 * @returns 댓글 목록과 페이지네이션 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function getReplyListApi(id: string): Promise<ListRes<Reply> | undefined> {
  try{
    const res = await axiosInstance.get<ListRes<Reply>>(`/posts/${id}/replies`);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 게시글에 새로운 댓글을 생성합니다.
 * @param id - 댓글을 생성할 게시글의 ID
 * @param reply - 생성할 댓글 정보
 * @returns 생성된 댓글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function createReplyApi(id: string, reply: CreateReplyRequest): Promise<DetailRes<Reply> | undefined> {
  try{
    const res = await axiosInstance.post<DetailRes<Reply>>(`/posts/${id}/replies`, reply);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}

/**
 * 게시글의 댓글을 삭제합니다.
 * @param postId - 댓글이 속한 게시글의 ID
 * @param replyId - 삭제할 댓글의 ID
 * @returns 삭제된 댓글 정보를 포함한 응답
 * @throws 네트워크 오류 또는 서버 오류 시 예외 발생
 */
export async function deleteReplyApi(postId: string, replyId: string): Promise<DetailRes<Reply> | undefined> {
  try{
    const res = await axiosInstance.delete<DetailRes<Reply>>(`/posts/${postId}/replies/${replyId}`);
    return res.data;
  }catch(err){
    handleAxiosError(err);
  }
}
```

## 3.3 댓글 목록 조회

### 3.3.1 댓글 목록 조회 기능 구현
#### src/pages/board/detail.ts에 추가
- replyListView, renderReplyList 함수 작성 

```ts
...
import { getReplyListApi } from "../../apis/post";
import type { Reply } from "../../types/post";

async function detailView(){
  ...
  render(data.item);
  replyListView();
}

...

/**
 * 댓글 목록을 조회하고 렌더링하는 함수
 * URL 쿼리 파라미터에서 게시글 ID를 가져와 해당 게시글의 댓글 목록을 조회하고 표시합니다.
 * 
 * @async
 * @function replyListView
 * @returns {Promise<void>}
 */
async function replyListView(){
  const id = new URLSearchParams(window.location.search).get('id');
  if(id){
    const data = await getReplyListApi(id);
    if(data?.ok){
      renderReplyList(data.item);
    }
  }
}

/**
 * 댓글 목록을 DOM에 렌더링하는 함수
 * Reply 배열을 받아서 각 댓글을 HTML로 변환하여 댓글 목록 영역에 삽입합니다.
 * 댓글 작성자 본인인 경우에만 삭제 버튼을 표시합니다.
 * 
 * @function renderReplyList
 * @param {Reply[]} replies - 렌더링할 댓글 배열
 * @returns {void}
 */
function renderReplyList(replies: Reply[]){
  // 사용자 정보 가져오기
  const user = getUser();
  const replySection = document.querySelector('#reply-section')!;
  const replyList = document.querySelector('#reply-list')!;

  // 댓글 개수 표시
  replySection.querySelector('#reply-count')!.innerHTML = `${replies.length}`;
  
  // 댓글 목록 초기화
  const id = new URLSearchParams(window.location.search).get('id');
  replyList.innerHTML = '';
  
  replies.forEach(reply => {
    // detail.html 파일에서 복사 후 수정
    replyList.innerHTML += `
      <div class="shadow-md rounded-lg p-4 mb-4">
        <div class="flex justify-between items-center mb-2">
          <div class="flex items-center">
            ${ reply.user.image ? `
              <img
                class="w-8 mr-2 rounded-full"
                src="${reply.user.image}"
                alt="${reply.user.name} 프로필 이미지"
              />
            ` : `
              <img
                class="w-8 mr-2 rounded-full"
                src="/assets/images/favicon.svg"
                alt="라이언 보드 로고"
              />
            ` }
            <a href="/" class="text-orange-400">${reply.user.name}</a>
          </div>
          <time class="text-gray-500" datetime="${reply.updatedAt}">${reply.updatedAt}</time>
        </div>
        <div class="flex justify-between items-start mb-2">
          <p class="whitespace-pre-wrap text-sm flex-1">${reply.content}</p>
          <form data-reply-id="${reply._id}" class="reply-delete-form inline ml-2" action="detail?id=${id}">
            ${ user?._id === reply.user._id ? `
              <button type="submit" class="bg-red-500 py-1 px-2 text-sm text-white font-semibold ml-2 hover:bg-amber-400 rounded">삭제</button>
            ` : ``}
          </form>
        </div>
      </div>
    `;
  });
}
```

### 3.3.2 html 정리
#### src/pages/board/detail.html 수정

- 더미 데이터인 댓글 수량 삭제

```html
...
<h4 class="mt-8 mb-4 ml-2">댓글
  <span id="reply-count">
  </span>
  개
</h4>
...
```

- `<div id="reply-list">`에 더미 데이터 내용 삭제

```html
...
<div id="reply-list">
  <!-- 댓글 목록 표시 영역 -->
</div>
...
```

### 3.3.3 댓글 목록 조회 테스트
- http://localhost:5173/src/pages/board/detail?id=21&type=info

## 3.4 댓글 등록

### 3.4.1 댓글 등록 기능 구현

#### src/pages/board/detail.ts에 추가

- addReply, handleAddReply, validateForm 함수 작성 

```ts
import { createReplyApi } from "../../apis/post";

...

/**
 * 댓글을 추가하는 함수
 * URL 쿼리 파라미터에서 게시글 ID를 가져와 새로운 댓글을 생성합니다.
 * 댓글 생성이 성공하면 댓글 목록을 다시 조회하여 화면을 갱신합니다.
 * 
 * @async
 * @function addReply
 * @returns {Promise<void>}
 */
async function addReply() {
  const id = new URLSearchParams(window.location.search).get('id');
  const replyForm = document.querySelector<HTMLFormElement>('#reply-form')!;
  const formData = new FormData(replyForm);
  const content = formData.get('content') as string;
  if(id){
    const data = await createReplyApi(id, { content });
    if(data?.ok){
      replyListView();
      replyForm.reset();
    }
  }
}

/**
 * 댓글 추가 폼 제출 이벤트 핸들러
 * 폼 제출 시 기본 동작을 막고, 입력된 댓글 내용을 검증한 후 댓글을 추가합니다.
 * 댓글 추가가 성공하면 폼을 초기화합니다.
 * 
 * @async
 * @function handleAddReply
 * @param {Event} event - 폼 제출 이벤트
 * @returns {Promise<void>}
 */
async function handleAddReply(event: Event) {
  event.preventDefault();
  const formElement = event.target as HTMLFormElement;
  const isValid = validateForm(formElement);
  if(isValid){
    addReply();
  }
}

/**
 * 댓글 추가 폼의 유효성을 검증하는 함수
 * 폼 요소에서 댓글 내용을 가져와 필수 입력 여부를 확인합니다.
 * 검증 실패 시 에러 메시지를 표시하고 해당 입력 필드에 포커스를 설정합니다.
 * 
 * @function validateForm
 * @param {HTMLFormElement} formElement - 검증할 폼 요소
 * @returns {boolean} - 검증 결과 (true: 유효함, false: 유효하지 않음)
 */
function validateForm(formElement: HTMLFormElement): boolean {
  let result: boolean = true;

  const content = formElement.querySelector<HTMLTextAreaElement>('[name=content]')!;

  if(content.value.trim() === ''){
    content.nextElementSibling!.textContent = '내용은 필수입니다.';
    content.focus();
    result = false;
  }else{
    content.nextElementSibling!.textContent = '';
  }

  return result;
}

document.querySelector('#reply-form')?.addEventListener('submit', handleAddReply);
```

### 3.4.2 댓글 등록 테스트
- http://localhost:5173/src/pages/board/detail?id=21&type=info

## 3.5 댓글 삭제

### 3.5.1 댓글 삭제 기능 구현
#### src/pages/board/detail.ts에 추가
- deleteReply 함수 작성 

```ts
import { deleteReplyApi } from "../../apis/post";

...

function renderReplyList(replies: Reply[]){

  ...

  // 댓글 삭제 이벤트 핸들러
  replyList.querySelectorAll<HTMLFormElement>('.reply-delete-form').forEach(form => {
    form.addEventListener('submit', (e) => {
      e.preventDefault();
      if(confirm('댓글을 삭제하시겠습니까?')){
        const replyId = form.dataset.replyId;
        if(replyId){
          deleteReply(replyId);
        }
      }
    });
  });
}

/**
 * 댓글을 삭제하는 함수
 * URL 쿼리 파라미터에서 게시글 ID를 가져와 지정된 댓글을 삭제합니다.
 * 삭제가 성공하면 댓글 목록을 다시 조회하여 화면을 갱신합니다.
 * 
 * @async
 * @function deleteReply
 * @param {string} replyId - 삭제할 댓글의 ID
 * @returns {Promise<void>}
 */
async function deleteReply(replyId: string) {
  const postId = new URLSearchParams(window.location.search).get('id');
  if(postId){
    const data = await deleteReplyApi(postId, replyId);
    if(data?.ok){
      replyListView();
    }
  }
}
```

### 3.5.2 댓글 삭제 테스트
- http://localhost:5173/src/pages/board/detail?id=21&type=info

## 3.6 게시물 검색

### 3.6.1 검색 기능 구현

#### src/pages/board/list.ts 수정

- handleSearch 함수 작성 

```ts
/**
 * 검색 폼 제출 이벤트 핸들러
 * 검색 키워드를 URL 쿼리 파라미터에 추가하고, 페이지를 새로고침하지 않고 목록을 다시 조회합니다.
 * 브라우저 히스토리에 URL을 추가하여 뒤로가기/앞으로가기가 가능하도록 합니다.
 * 
 * @function handleSearch
 * @param {Event} event - 폼 제출 이벤트 객체
 * @returns {void}
 */
function handleSearch(event: Event) {
  event.preventDefault();

  // url에 keyword 쿼리 파라미터 추가
  const target = event.target as HTMLFormElement;
  const formData = new FormData(target);
  const keyword = formData.get('keyword') as string;
  const url = new URL(window.location.href);
  url.searchParams.set('keyword', keyword);
  window.history.pushState({}, '', url.toString());
  listView();
}

document.querySelector('#search-form')!.addEventListener('submit', handleSearch);
```

- listView 함수 수정
  - keyword 쿼리 파라미터 추출
  - 게시물 목록 조회 API 호출시 keyword 적용

```ts
async function listView(){
  const type = new URLSearchParams(window.location.search).get('type') || 'info';
  const keyword = new URLSearchParams(window.location.search).get('keyword') || '';
  const data = await getPostListApi({ type, limit: LIMIT, keyword });
  if(data?.ok){
    render(data.item);
  }
}
```

- render 함수에 url의 검색어를 추출해서 검색어 입력항목에 지정하는 코드 추가

```ts
function render(posts: Post[]) {
  const keyword = new URLSearchParams(window.location.search).get('keyword') || '';
  (document.querySelector('#search-form > input[name="keyword"]') as HTMLInputElement).value = keyword;

  ...

}
```

### 3.6.2 검색 테스트
- http://localhost:5173/src/pages/board/list?type=info
  - api, vscode, git 등으로 검색

## 3.7 게시물 목록 pagination

### 3.7.1 pagination 기능 구현

#### src/pages/board/list.ts 수정

- renderPagination 함수 작성 

```ts
import type { Pagination } from "../../types/api";

...

/**
 * 페이지네이션 UI를 렌더링하는 함수
 * 페이지네이션 정보를 받아서 페이지 번호 링크를 생성하고,
 * 현재 페이지를 강조 표시합니다.
 * 
 * @function renderPagination
 * @param {Pagination} pagination - 페이지네이션 정보 (page, limit, total, totalPages)
 * @returns {void}
 */
function renderPagination(pagination: Pagination) {
  const searchParams = new URLSearchParams(window.location.search);
  const keyword = searchParams.get('keyword') || '';
  const currentPage = searchParams.get('page') || '1';
  const pageListElement = document.querySelector('#pagination > ul')!;

  let pageList = '';
  for(let i = 1; i <= pagination.totalPages; i++) {
    const isActive = i === parseInt(currentPage);
    // list.html 파일에서 복사
    pageList += `
      <li class="${isActive ? 'font-bold text-blue-700' : ''}"><a href="list?type=info&keyword=${keyword}&page=${i}">${i}</a></li>
    `;
  }
  pageListElement.innerHTML = pageList;
}
```

- listView 함수 수정
  - page 쿼리 파라미터 추출
  - 게시물 목록 조회 API 호출시 page 적용
  - renderPagination() 호출 추가

```ts
async function listView(){
  const type = new URLSearchParams(window.location.search).get('type') || 'info';
  const keyword = new URLSearchParams(window.location.search).get('keyword') || '';
  const page = new URLSearchParams(window.location.search).get('page') || '1';
  const data = await getPostListApi({ type, limit: LIMIT, keyword, page });
  if(data?.ok){
    render(data.item);
    renderPagination(data.pagination);
  }
}
```

### 3.7.2 html 정리

#### src/pages/board/list.html 수정

- 더미 데이터인 `<div id="pagination">` 하위 `<li>` 요소 삭제

```html
...
<div id="pagination">
  <ul class="flex justify-center gap-3 m-4">
    <!-- 페이지 출력 -->
  </ul>
</div>
...
```

### 3.7.3 pagination 테스트
- http://localhost:5173/src/pages/board/list?type=info

## 3.8 로그인 만료시 재 로그인 처리
- 만료된 accessToken은 더이상 사용할 수 없어서 사용자 인증이 안되므로 재발행 필요

### 3.8.1 로그인 만료 처리
- 로그인 요청시 accessToken의 만료 기간을 expiresIn 파라미터로 전송
  - 생략 시 기본은 1d(1일)이지만 토큰 만료 테스트를 위해 직접 만료기간을 지정할 수 있도록 함
- expiresIn 값 예시
  - 1d: 1일, 2h: 2시간, 5m: 5분, 10s: 10초

#### src/pages/user/login.ts 수정
- 수정 전
  ```ts
  const res = await axiosInstance.post<DetailRes<UserDetail>>('/users/login', { email, password });
  ```

- 수정 후
  ```ts
  const res = await axiosInstance.post<DetailRes<UserDetail>>('/users/login?expiresIn=10s', { email, password });
  ```

#### 로그인 만료 테스트

- 로그아웃 후 다시 로그인

- 로그인 후 10초가 지나면 게시물 삭제 테스트시 삭제 불가

- 서버 응답
```json
{
  "ok":0,
  "message": "토큰이 만료되었습니다.","errorName":"TokenExpiredError"
}
```

### 3.8.2 accessToken 재발행

- 서버에서 401 Unauthorized 상태코드로 응답을 하면 refreshToken을 이용해 accessToken을 재발행하는 로직을 구현해 두면 refreshToken 만료기간 만큼 재 로그인 없이 사용자 인증 가능

#### 재발행 기본 흐름
1. API 서버가 401 상태코드를 응답하면 클라이언트는 저장해 둔 refreshToken을 꺼냄
2. 재발행 엔드포인트에 refreshToken을 보내 새 accessToken(필요하면 refreshToken 도)을 전달받음
3. 재발행 받은 accessToken으로 기존 스토리지에 저장해둔 토큰을 갱신하고 401 상태코드를 응답받았던(실패했던) 요청을 재시도
4. refreshToken 까지 만료됐거나 유효하지 않으면 로그인 페이지로 이동

### 3.8.3 accessToken 재발행 구현

#### src/utils/user.ts 수정
- navigateLogin 함수 추가

```ts
/**
 * 로그인 페이지로 이동하는 함수
 * 사용자에게 로그인 페이지 이동 여부를 확인하고,
 * 확인 시 현재 페이지 경로를 from 쿼리 파라미터에 포함하여 로그인 페이지로 이동합니다.
 * 취소 시 이전 페이지로 돌아갑니다.
 * 
 * @function navigateLogin
 * @returns {void}
 */
export function navigateLogin(){
  const gotoLogin = confirm('로그인 후 이용 가능합니다.\n로그인 페이지로 이동하시겠습니까?');
  if(gotoLogin){
    // 현재 페이지를 from 쿼리 파라미터에 지정해서 로그인 페이지로 이동
    // 로그인이 완료되면 from 쿼리 파라미터에 지정된 페이지로 이동
    location.replace(`/src/pages/user/login?from=${location.pathname}`);
  }else{
    // 이전 페이지로 이동
    history.back();
  }
}
```

#### src/apis/axios.ts 수정

```ts
import { setUser, navigateLogin} from './user';
// access token 재발행 URL
const REFRESH_URL = '/auth/refresh';

...

export function getAxios(): AxiosInstance {
  ...
  instance.interceptors.request.use((config) => {
    ...
  }, (error) => {
    ...
  });

  instance.interceptors.response.use((response) => {
    ...
  }, async(error) => {
    ...
    
    const { config } = error;
    if(error.status === 401){ // 인증 실패
      if(config.url === REFRESH_URL){ // refresh token 만료
        navigateLogin();
      }else if(user){ // 로그인 했으나 access token 만료된 경우
        // refresh 토큰으로 access 토큰 재발행 요청
        const { data: { accessToken } } = await instance.get(REFRESH_URL, {
          headers: {
            Authorization: `Bearer ${user.token.refreshToken}`
          }
        });
        // 갱신된 accessToken으로 스토리지 업데이트
        setUser({ ...user, token: { accessToken }});
        // 갱신된 accessToken으로 재요청
        config.headers.Authorization = `Bearer ${ accessToken }`;
        return axios(config);
      }else{ // 로그인 안한 경우
        navigateLogin();
      }
    }

    return Promise.reject(error);
  });

  return instance;
}

...
```

#### src/pages/user/login.ts 수정

```ts
async function login(formElement: HTMLFormElement) {
  ...
  if(loginRes?.ok){
    ...
    alert('로그인이 완료되었습니다.');
    const fromUrl = new URLSearchParams(location.search).get('from') || '/';
    // 뒤로가기 이동시 다시 로그인 페이지로 이동하는 문제를 해결하기 위해 현재 히스토리를 덮어 씌우는 replace 메서드 사용
    location.replace(fromUrl);
  }
}
```

#### src/pages/board/new.ts 수정

- 로그인 된 사용자만 게시글을 작성해야 한다면 로그인 체크 로직 추가

```ts
...

import { getUser, navigateLogin } from "../../utils/user";

/**
 * 로그인 여부 확인
 * 로그인 안한 경우 로그인 페이지로 이동
 */
const user = getUser();
if(!user){
  navigateLogin();
}

...
```

### 3.8.4 accessToken 재발행 테스트

- 로그아웃 후 다시 로그인

- 로그인 후 10초가 지난후 게시물 삭제 테스트시 accessToken 재발행으로 삭제 가능

- 서버 응답
```json
{
  "ok":0,
  "message": "토큰이 만료되었습니다.","errorName":"TokenExpiredError"
}
```

- 자동으로 accessToken 재발행 요청

- 서버 응답
```json
{
  "ok": 1,
  "accessToken": "eyJhbGci..."
}
```

- 자동으로 이전에 실패한 요청을 다시 요청

- 서버 응답(삭제 성공)
```json
{ "ok": 1 }
```

### 3.8.5 로그인하지 않은 상태로 글작성 테스트
- 로그아웃 후 글작성 시도
```
로그인 후 이용 가능합니다.
로그인 페이지로 이동하시겠습니까?
```

- 확인 클릭 후 로그인 페이지로 이동하면 이메일, 비밀번호 입력 후 로그인
- 로그인 완료 후 글작성 페이지로 이동되는지 확인

## 3.9 자유게시판, 질문게시판
- 게시판의 종류는 게시물 목록 조회, 게시물 등록시 API 서버에 전달하는 type 쿼리 파라미터로 구분
- 각 게시판내의 페이지 이동시 type 파라미터를 유지 해야 함

### 3.9.1 자유게시판, 질문게시판 기능 구현
#### 페이지 이동 규칙
- 자유게시판 목록 화면(list?type=free)
  - `검색` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
  - `글작성` 버튼 클릭시 자유게시판 등록 화면으로 이동(new?type=free)
  - 게시물 제목 클릭시 자유게시판 상세 화면으로 이동(detail?type=free)
- 자유게시판 등록 화면(new?type=free)
  - `등록` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
  - `취소` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
- 자유게시판 상세 화면(detail?type=free)
  - `목록` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
  - `수정` 버튼 클릭시 자유게시판 수정 화면으로 이동(edit?type=free)
  - `삭제` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
- 자유게시판 수정 화면(edit?type=free)
  - `수정` 버튼 클릭시 자유게시판 상세 화면으로 이동(detail?type=free)
  - `취소` 버튼 클릭시 자유게시판 상세 화면으로 이동(detail?type=free)

#### 게시판 목록 화면
- src/pages/list.ts 수정
- `검색` 버튼 클릭시 자유게시판 목록 화면으로 이동(👍)
- `글작성` 버튼 클릭시 자유게시판 등록 화면으로 이동(👎)
- 게시물 제목 클릭시 자유게시판 상세 화면으로 이동(👍)

```ts
function renderSkeleton() {
  ...

  // `글작성` 버튼 클릭시 자유게시판 등록 화면으로 이동(new?type=free)
  const type = new URLSearchParams(window.location.search).get('type') || 'info';
  const newButton = document.querySelector('#search-form + a') as HTMLAnchorElement;
  newButton.href = `new?type=${type}`;
}
```

#### 게시판 등록 화면
- src/pages/new.ts 수정
- `등록` 버튼 클릭시 자유게시판 목록 화면으로 이동(👍)
- `취소` 버튼 클릭시 자유게시판 목록 화면으로 이동(👎)

```ts
...

// `취소` 버튼 클릭시 자유게시판 목록 화면으로 이동(list?type=free)
const cancelButton = document.querySelector('#button-container > a') as HTMLAnchorElement;
const type = new URLSearchParams(window.location.search).get('type') || 'info';
cancelButton.href = `list?type=${type}`;
```

#### 게시판 상세 화면
- src/pages/detail.ts
- `목록` 버튼 클릭시 자유게시판 목록 화면으로 이동(👍)
- `수정` 버튼 클릭시 자유게시판 수정 화면으로 이동(👍)
- `삭제` 버튼 클릭시 자유게시판 목록 화면으로 이동(👍)

#### 게시판 수정 화면
- src/pages/edit.ts 수정
- `수정` 버튼 클릭시 자유게시판 상세 화면으로 이동(👍)
- `취소` 버튼 클릭시 자유게시판 상세 화면으로 이동(👎)

```ts
function render(post: Post) {
  ...

  // `취소` 버튼 클릭시 자유게시판 상세 화면으로 이동(detail?type=free)
  const cancelButton = document.querySelector('#button-container > a') as HTMLAnchorElement;
  const type = new URLSearchParams(window.location.search).get('type') || 'info';
  const id = new URLSearchParams(window.location.search).get('id');
  cancelButton.href = `detail?id=${id}&type=${type}`;
}
```

### 3.9.2 게시판 링크 테스트
- 정보공유, 자유게시판, 질문게시판에서 각 링크 클릭해서 페이지 이동할 때 주소창에 type 속성이 중간에 바뀌지 않는지 확인

## 3.10 라이언 보드 v03 완성
- 완성 코드 참고: https://github.com/FEBC-15/project-vanilla-lionboard/tree/main/src-v03